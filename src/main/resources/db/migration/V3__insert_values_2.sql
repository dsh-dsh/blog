insert into posts
(is_active, moderation_status, text, time, title, view_count, user_id, moderator_id)
values
(1, 'NEW', 'Предположим, вы решили, что работа по проблеме #53 закончена и её можно влить в ветку master. ', '2021-07-20 07:55:45', "1 Writing migrations manually", 1, 2, null),
(1, 'ACCEPTED', 'The above configuration specifies that our migration scripts are located in the db/migration directory.It connects to an in-memory H2 instance using databaseUser and databasePassword.The application database schema is app-db.Of course, we replace flyway.user, flyway.password, and flyway.url with our own database username, database password, and database URL appropriately.', '2021-07-21 07:55:45', "2 The above configuration specifies that", 1, 3, 1),
(1, 'ACCEPTED', 'как можно написать регулярное выражение для нахождения открывающих и закрывающих html-тегов. Мои косячат, а причину понять не могу как можно написать регулярное выражение для нахождения открывающих и закрывающих html-тегов. Мои косячат, а причину понять не могу как можно написать регулярное выражение для нахождения открывающих и закрывающих html-тегов. Мои косячат, а причину понять не могу', '2021-07-15 16:55:00', "3 Мои косячат, а причину понять не могу", 1, 2, 1),
(1, 'ACCEPTED', 'We can modify the state of the database also with a native query. We just need to add the @Modifying annotation: We can modify the state of the database also with a native query. We just need to add the @Modifying annotation: We can modify the state of the database also with a native query. We just need to add the @Modifying annotation:', '2021-07-21 12:50:00', "4 We just need to add the @Modifying annotation", 1, 2, 1),
(1, 'ACCEPTED', 'Often, well encounter the need for building SQL statements based on conditions or data sets whose values are only known at runtime. And in those cases, we cant just use a static query.', '2021-07-14 19:27:00', "5 We cant just use a static query", 1, 2, 1),
(1, 'ACCEPTED', 'Предположим, вы решили, что работа по проблеме #53 закончена и её можно влить в ветку master. Для этого нужно выполнить слияние ветки iss53 точно так же, как вы делали это с веткой hotfix ранее. Все, что нужно сделать переключиться на ветку, в которую вы хотите включить изменения, и выполнить команду git merge:', '2021-07-22 07:55:45', "6 Все, что нужно сделать переключиться на ветку", 1, 3, 1),
(1, 'ACCEPTED', 'Writing migrations manually takes a lot of time; instead, we can generate them based on our JPA entities. We can achieve this using a plugin for IntelliJ IDEA called JPA Buddy. Writing migrations manually takes a lot of time; instead, we can generate them based on our JPA entities. We can achieve this using a plugin for IntelliJ IDEA called JPA Buddy.', '2019-07-12 07:55:45', "7 IntelliJ IDEA called JPA Buddy", 1, 3, 1),
(1, 'ACCEPTED', 'Результат этой операции отличается от результата слияния ветки hotfix. В данном случае процесс разработки ответвился в более ранней точке. Так как коммит, на котором мы находимся, не является прямым родителем ветки, с которой мы выполняем слияние, Git придётся немного потрудиться. В этом случае Git выполняет простое трёхстороннее слияние, используя последние коммиты объединяемых веток и общего для них родительского коммита.', '2018-07-11 11:43:15', "8 В этом случае Git выполняет простое трёхстороннее слияние", 1, 1, 1),
(1, 'ACCEPTED', 'For example, its a common practice to generate database schema based on the entities during tests. In such a situation, we can disable Flyway under the test profile For example, its a common practice to generate database schema based on the entities during tests. In such a situation, we can disable Flyway under the test profile.', '2021-07-19 13:23:15', "9 Flyway under the test profile", 1, 1, 1),
(1, 'ACCEPTED', 'Заметили фразу «fast-forward» в этом слиянии? Git просто переместил указатель ветки вперед, потому что коммит C4, на который указывает слитая ветка hotfix, был прямым потомком коммита C2, на котором вы находились до этого. Другими словами, если коммит сливается с тем, до которого можно добраться двигаясь по истории прямо, Git упрощает слияние просто перенося указатель ветки вперед, так как нет расхождений в изменениях. Это называется «fast-forward»', '2021-07-10 01:15:55', "10 Git просто переместил указатель ветки вперед", 1, 2, null),
(1, 'ACCEPTED', 'One question that comes to mind is that if we can write any query with specifications then when do we prefer query methods? Or should we ever prefer them? I believe there are a couple of cases where query methods could come in handy.Let’s say our entity has only a handful of fields, and it only needs to be queried in a certain way then why bother writing Specifications when we can simply write a query method?', '2020-07-07 01:15:55', "11 Only needs to be queried in a certain way", 1, 3, null),
(1, 'ACCEPTED', 'Specifications provide us with a way to write reusable queries and also fluent APIs with which we can combine and build more sophisticated queries.All in all, Spring JPA Specifications is a great tool whether we want to create reusable predicates or want to generate typesafe queries programmatically', '2021-07-05 01:15:55', "12 All in all, Spring JPA Specifications is a great tool", 1, 1, 1),
(1, 'ACCEPTED', 'как можно написать регулярное выражение для нахождения открывающих и закрывающих html-тегов. Мои косячат, а причину понять не могу как можно написать регулярное выражение для нахождения открывающих и закрывающих html-тегов. Мои косячат, а причину понять не могу как можно написать регулярное выражение для нахождения открывающих и закрывающих html-тегов. Мои косячат, а причину понять не могу', '2021-07-15 16:55:00', "13 Выражение для нахождения открывающих и закрывающих html-тегов", 1, 2, 1),
(1, 'ACCEPTED', 'We can modify the state of the database also with a native query. We just need to add the @Modifying annotation: We can modify the state of the database also with a native query. We just need to add the @Modifying annotation: We can modify the state of the database also with a native query. We just need to add the @Modifying annotation:', '2021-07-21 12:50:00', "14 The database also with a native query", 1, 2, 1),
(1, 'DECLINED', 'Often, well encounter the need for building SQL statements based on conditions or data sets whose values are only known at runtime. And in those cases, we cant just use a static query.', '2021-07-14 19:27:00', "15 We cant just use a static query", 1, 2, 1),
(1, 'ACCEPTED', 'Предположим, вы решили, что работа по проблеме #53 закончена и её можно влить в ветку master. Для этого нужно выполнить слияние ветки iss53 точно так же, как вы делали это с веткой hotfix ранее. Все, что нужно сделать переключиться на ветку, в которую вы хотите включить изменения, и выполнить команду git merge:', '2021-07-22 07:55:45', "16 И выполнить команду git merge", 1, 3, 1),
(1, 'ACCEPTED', 'Writing migrations manually takes a lot of time; instead, we can generate them based on our JPA entities. We can achieve this using a plugin for IntelliJ IDEA called JPA Buddy. Writing migrations manually takes a lot of time; instead, we can generate them based on our JPA entities. We can achieve this using a plugin for IntelliJ IDEA called JPA Buddy.', '2021-07-12 07:55:45', "17 Writing migrations manually takes a lot of time", 1, 3, 1);

insert into tags
(name)
values
("java"),
("hibernate"),
("mySql"),
("spring");